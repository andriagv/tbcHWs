import Foundation


// MARK: - task1
/* შექმენით "Genre" ტიპის enum, რომელიც შეიცავს წიგნის ჟანრებს (მაგ: fiction, nonFiction, mystery, sciFi, biography). დაამატეთ computed property "description", რომელიც დააბრუნებს ჟანრის აღწერას.  */


// MARK: - task2
/* შექმენით enum "ReadingLevel" მნიშვნელობებით: beginner, intermediate, advanced. შემდეგ შექმენით პროტოკოლი "Readable" შემდეგი მოთხოვნებით:
 
 - "title: String" ფროფერთი

 - "author: String" ფროფერთი

 - "publicationYear: Int" ფროფერთი

 - "readingLevel: ReadingLevel" ფროფერთი

 - "read()" მეთოდი, რომელიც დაბეჭდავს ინფორმაციას წიგნის წაკითხვის შესახებ, მაგ: "გილოცავთ თქვენ ერთ კლიკში წაიკითხეთ წიგნი" ან რამე სხვა, მიეცით ფანტაზიას გასაქანი 🤘 */


// MARK: - task3
/* შექმენით სტრუქტურა "Book", რომელიც დააკმაყოფილებს "Readable" პროტოკოლს. დაამატეთ "genre: Genre" ფროფერთი და "description()" მეთოდი, რომელიც დაბეჭდავს სრულ ინფორმაციას წიგნზე. */


// MARK: - task4
/* შექმენით "Library" კლასი შემდეგი ფროფერთებით:
 
 - "name: String" - ბიბლიოთეკის სახელი

 - "books: [Book]" - წიგნების მასივი



 დაამატეთ მეთოდები:

 - "add(book: Book)" - წიგნის დამატება

 - "removeBookWith(title: String)" - წიგნის წაშლა სათაურის მიხედვით

 - "listBooks()" - ყველა წიგნის ჩამონათვალის დაბეჭდვა


  გააფართოეთ “Library” კლასი “filterBooks” მეთოდით რომელიც არგუმენტად მიიღებს ქლოჟერს და დააბრუნებს ამ ქლოჟერის გამოყენებით გაფილტრულ წიგნთა მასივს. */

// MARK: - task5
/* შექმენით generic ფუნქცია groupBooksByLevel<T: Readable>(_ books: [T]) -> [ReadingLevel: [T]], რომელიც დააჯგუფებს წიგნებს კითხვის დონის მიხედვით. გამოიყენეთ ეს ფუნქცია ბიბლიოთეკის წიგნებზე და დაბეჭდეთ შედეგი.
 
 */

// MARK: - task6
/* შექმენით "LibraryMember" კლასი შემდეგი ფროფერთებით:
 
 - "id: Int"

 - "name: String"

 - "borrowedBooks: [Book]"



 დაამატეთ მეთოდები:

 - "borrowBook(_ book: Book, from library: Library)" - წიგნის გამოწერა ბიბლიოთეკიდან

 - "returnBook(_ book: Book, to library: Library)" - წიგნის დაბრუნება ბიბლიოთეკაში  */

// MARK: - task7
/* შექმენით მინიმუმ 5 "Book" ობიექტი და 1 "Library" ობიექტი. დაამატეთ წიგნები ბიბლიოთეკაში "add(book:)" მეთოდის გამოყენებით. შემდეგ:
 
 - გამოიყენეთ "listBooks()" მეთოდი ყველა წიგნის ჩამოსათვლელად

 - წაშალეთ ერთი წიგნი "removeBookWith(title:)" მეთოდის გამოყენებით

 - გამოიყენეთ "filterBooks" მეთოდი და დაბეჭდეთ მხოლოდ ის წიგნები, რომლებიც გამოცემულია 2000 წლის შემდეგ  */

// MARK: - task8
/* შექმენით მინიმუმ 2 "LibraryMember" ობიექტი. თითოეული წევრისთვის:
 
 - გამოიწერეთ 2 წიგნი "borrowBook(_:from:)" მეთოდის გამოყენებით

 - დააბრუნეთ 1 წიგნი "returnBook(_:to:)" მეთოდის გამოყენებით

 დაბეჭდეთ თითოეული წევრის გამოწერილი წიგნების სია  */


// MARK: - BOUNS

// MARK: - task9
/* გააფართოვეთ "Array" ტიპი, სადაც ელემენტი აკმაყოფილებს "Readable" პროტოკოლს (ანუ ამ ექსთენშენი მოცემული მეთოდები ხელმსიაწვდომი იქნება მხოლოდ [Readable] მასივისთვის), შემდეგი მეთოდებით:
 
 - "findByAuthor(_ author: String) -> [Readable]" - აბრუნებს ავტორის მიხედვით ნაპოვნ წიგნებს

 - "oldestBook() -> Readable?" - აბრუნებს ყველაზე ძველ წიგნს */

// MARK: - task10
/* შექმენით "EBook" სტრუქტურა, რომელიც დააკმაყოფილებს "Readable" პროტოკოლს და დაამატეთ "fileSize: Double" ფროფერთი.
 
   გამოიყენეთ "extension", რომ დაამატოთ "printDetails()" მეთოდი, რომელიც დაბეჭდავს ელექტრონული წიგნის დეტალებს.

   შექმენით მინიმუმ 2 "EBook" ობიექტი და გამოიძახეთ "printDetails()" მეთოდი თითოეულისთვის. */

// MARK: - task11
/* შექმენით ჯენერიკ ფუნქცია "findMostFrequent<T: Hashable>(_ array: [T]) -> T?", რომელიც იპოვის და დააბრუნებს მასივში ყველაზე ხშირად გამეორებულ ელემენტს. თუ რამდენიმე ელემენტი თანაბრად ხშირად მეორდება, დააბრუნეთ პირველი მათგანი. */

// MARK: - task12
/* შექმენით მასივი, რომელიც შეიცავს ყველა წიგნის ავტორს მე-7 დავალებაში შექმნილი ბიბლიოთეკიდან.
 
 გამოიძახეთ "findMostFrequent" ფუნქცია ამ მასივზე, რათა იპოვოთ ყველაზე პოპულარული ავტორი.
 დაბეჭდეთ შედეგი: "ბიბლიოთეკაში ყველაზე პოპულარული ავტორი არის: [ავტორის სახელი]". */



